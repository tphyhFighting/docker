diff --git a/conf/app.conf b/conf/app.conf
index e940cbb..4106f93 100644
--- a/conf/app.conf
+++ b/conf/app.conf
@@ -1,6 +1,11 @@
 appname = imgfit
 httpport = 8000
+httpcacheport = 9000
 runmode = dev
 autorender = false
 copyrequestbody = true
 EnableDocs = true
+EnableMyCacheSer=true
+beego.EnableAdmin = true
+beego.AdminAddr = "localhost"
+beego.AdminPort = 8088
diff --git a/controllers/cache.go b/controllers/cache.go
index 3a7a8f4..27be5df 100644
--- a/controllers/cache.go
+++ b/controllers/cache.go
@@ -10,7 +10,8 @@ import (
 	"net"
 	"fmt"
 	"net/url"
-	"crypto/sha1"
+	//"crypto/sha1"
+	"strings"
 )
 
 type CacheManager struct {
@@ -34,13 +35,12 @@ func NewCache(name string, size int64, port int) (*CacheManager, error) {
 	return &CacheManager{cache, pool, _url, nil}, nil
 }
 func (cm *CacheManager) Join(sr *ServiceRegistry) error {
-	logger.Debugf("CacheManager Join enter")
-	defer func() {
-		logger.Debugf("CacheManager Join end")
-	}()
+	//logger.Debugf("CacheManager Join enter")
+	//defer func() {
+	//	logger.Debugf("CacheManager Join end")
+	//}()
 	//Use hashed url as ID to prevent duplication
 	name := hashId(cm.url)
-	logger.Debugf("Register this node as name:%s\n", name)
 	sr.Register(name, cm.url)
 
 	//Init peers
@@ -51,30 +51,43 @@ func (cm *CacheManager) Join(sr *ServiceRegistry) error {
 
 	addPeers(cm.pool, nodes)
 
+	//watch nodes
 	go func() {
-		logger.Debugf("watch: %v", nodes)
+		logger.Infof("Watch nodes:%v", nodes)
 		sr.Watch(func(nodes []Node) {
 			addPeers(cm.pool, nodes)
 		})
 	}()
+
 	cm.reg = sr
 
 	return nil
 }
 func (cm *CacheManager) Get(key string) (data[]byte, err error) {
 	var ctx groupcache.Context
-	logger.Infof("cache get..start, key:%v ctx:%v", key, ctx)
+	key = strings.Replace(key, "/", "_", 1)
+	//logger.Infof("Cache get..start, key:%v ctx:%v", key, ctx)
 	err = cm.cache.Get(ctx, key, groupcache.AllocatingByteSliceSink(&data))
-	logger.Infof("cache get..end, err:%v", err)
+	//logger.Infof("Cache get..end, err:%v", err)
 	return data, err
 }
+func (cm *CacheManager) Leave() {
+	if cm.reg != nil {
+		name := hashId(cm.url)
+		err := cm.reg.Unregister(name)
+
+		if err != nil {
+			logger.Errorf("err:%v", err)
+		}
+	}
+}
 
 func getter(ctx groupcache.Context, key string, dest groupcache.Sink) error {
-	logger.Debugf("thumbnail , key:%v", key)
+	logger.Debugf("getter , key:%v", key)
 	fileName := key
 	bytes, err := generateThumbnail(fileName)
 	if err != nil {
-		logger.Errorf("thumbnail err: %v", err)
+		logger.Errorf("getter err: %v", err)
 		return err
 	}
 	dest.SetBytes(bytes)
@@ -83,11 +96,20 @@ func getter(ctx groupcache.Context, key string, dest groupcache.Sink) error {
 
 func generateThumbnail(key string) ([]byte, error) {
 	logger.Debugf("key:%v begin", key)
-	//u, _ := url.Parse("http://localhost:8000"+key)
-	u, _ := url.Parse("http://192.168.9.41:8000"+key)
+	key = strings.Replace(key, "_", "/", 1)
+	//todo 拼接url修改. 访问错误时，核查key
+	u, _ := url.Parse("http://127.0.0.1:8000"+key)
+	//q := u.Query()
+	//query, err := url.ParseQuery(key)
+	//if err != nil {
+	//	return nil, err
+	//}
+	//for _, k := range query {
+	//	q.Set(k, query[k])
+	//}
 	//u.Path = key
 	//暂时不区分v1/v2key
-	logger.Debugf("url-key:%v .... u:%v", u.String(), u)
+	//logger.Debugf("url-key:%v .... u:%v", u.String(), u)
 	resp, err := http.Get(u.String())
 	defer resp.Body.Close()
 	logger.Debugf("key:%v http.get end...StatusCode:%v err:%v", key, resp.StatusCode, err)
@@ -101,7 +123,10 @@ func generateThumbnail(key string) ([]byte, error) {
 	return ioutil.ReadAll(resp.Body)
 }
 func addPeers(pool *groupcache.HTTPPool, nodes []Node) {
-	logger.Debugf("addPeers: %v nodes:%v", pool, nodes)
+	//logger.Debugf("addPeers: %v nodes:%v start", pool, nodes)
+	defer func() {
+		logger.Debugf("addPeers: %v end", pool)
+	}()
 	if nodes == nil || len(nodes) == 0 {
 		return
 	}
@@ -131,5 +156,6 @@ func getMyIp() (string, error) {
 	return "", errors.New("No available network interface")
 }
 func hashId(s string) string {
-	return fmt.Sprintf("%02x", sha1.Sum([]byte(s)))
+	//return fmt.Sprintf("%02x", sha1.Sum([]byte(s)))
+	return strings.Replace(s, "/", "_", 2)
 }
diff --git a/controllers/discovery.go b/controllers/discovery.go
index e04da30..734e6af 100644
--- a/controllers/discovery.go
+++ b/controllers/discovery.go
@@ -1,14 +1,21 @@
 package controllers
 
 import(
+	"net/http"
+	"os"
+	"os/signal"
+	"syscall"
 	"fmt"
 	"regexp"
 	"time"
 	"imgfit/logger"
 	"golang.org/x/net/context"
 	etcd "github.com/coreos/etcd/client"
+	"net/url"
 )
 
+const HEALTHCHECKINTERVAL = time.Minute
+
 type ServiceRegistry struct {
 	etcd_client etcd.KeysAPI
 	name        string
@@ -29,7 +36,6 @@ func NewServiceRegistry(name string, endpoints []string) (*ServiceRegistry, erro
 		// set timeout per request to fail fast when the target endpoint is unavailable
 		HeaderTimeoutPerRequest: time.Second,
 	}
-	logger.Debugf("NewServiceRegistry cfg:%v", cfg)
 
 	c, err := etcd.New(cfg)
 	if err != nil {
@@ -38,19 +44,75 @@ func NewServiceRegistry(name string, endpoints []string) (*ServiceRegistry, erro
 
 	kapi := etcd.NewKeysAPI(c)
 	sr := ServiceRegistry{kapi, name, context.TODO()}
-	logger.Debugf("NewServiceRegistry sr:%v", sr)
+	logger.Debugf("NewServiceRegistry sr:%v cfg:%v end", sr, cfg)
 	return &sr, nil
 }
 
 func (s *ServiceRegistry) Register(name string, _url string) error {
 	//key name
-	logger.Debugf("ServiceRegistry Register name:%v _url:%v start", name, _url)
-	defer func() {
-		logger.Debugf("ServiceRegistry Register name:%v _url:%v end", name, _url)
-	}()
+	//logger.Debugf("ServiceRegistry Register name:%v _url:%v start", name, _url)
+	//defer func() {
+	//	logger.Debugf("ServiceRegistry Register name:%v _url:%v end", name, _url)
+	//}()
 	key := fmt.Sprintf("%s/nodes/%s", s.name, name)
 	_, err := s.etcd_client.Set(s.ctx, key, _url, nil)
 
+	//Listening to exit signals for graceful leave
+	go func() {
+		c := make(chan os.Signal, 1)
+		//kill 可以手动杀死节点测试
+		//signal.Notify(c, os.Interrupt, syscall.SIGINT, syscall.SIGTERM, syscall.SIGKILL)
+		signal.Notify(c, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)
+		checkHealthCntMap := map[string]int{}
+		for {
+			select {
+			//health check
+			case <-time.After(HEALTHCHECKINTERVAL):
+				logger.Debugf("Health checkHealthCntMap:%v", checkHealthCntMap)
+				//同步checkHealthCntMap与nodes
+				for k, _ := range checkHealthCntMap{
+					nodeToKey := fmt.Sprintf("%s/nodes/%s", s.name, k)
+					_, err := s.etcd_client.Get(s.ctx, nodeToKey, &etcd.GetOptions{Recursive: true})
+					if err != nil {
+						delete(checkHealthCntMap, k)
+					}
+
+				}
+
+				urlCheckList, err := s.GetNodes()
+				if err != nil {
+					continue
+				}
+				for _, node := range urlCheckList{
+					link := node.Url
+					if err := healthCheck(link); err != nil {
+						cnt, _ := checkHealthCntMap[link]
+						checkHealthCntMap[link] = cnt + 1
+						logger.Errorf("err:%v checkHealthCntMap", checkHealthCntMap)
+					}else{
+						checkHealthCntMap[link] = 0
+					}
+
+					//peek 5m healthCheck fail, will delete node
+					if cnt,_ := checkHealthCntMap[link]; cnt > 5 {
+						nodeToKey := fmt.Sprintf("%s/nodes/%s", s.name, node.Name)
+						_, err := s.etcd_client.Delete(s.ctx, nodeToKey, &etcd.DeleteOptions{Recursive: true})
+						logger.Warnf("PEEK DEAD, Ser..done: name:%v url:%v, err:%v node:%v", s.name, link, err, node)
+						delete(checkHealthCntMap, link)
+					}
+				}
+			case <-c:
+				logger.Warn("SIG DONE, WILL DELETE NODE")
+				_, err := s.etcd_client.Delete(s.ctx, key, &etcd.DeleteOptions{Recursive: true})
+				logger.Warnf("Ser..done: cache_name:%v cm_url:%v, err:%v", cache_name, cm.url, err)
+				goto FOREND
+			}
+		}
+
+		FOREND:
+		os.Exit(0)
+	}()
+
 	return err
 }
 func (s *ServiceRegistry) Unregister(name string) error {
@@ -66,12 +128,16 @@ func (s *ServiceRegistry) Unregister(name string) error {
 func (s *ServiceRegistry) GetNodes() ([]Node, error) {
 	key := fmt.Sprintf("/%s/nodes", s.name)
 	getResp, err := s.etcd_client.Get(s.ctx, key, &etcd.GetOptions{Recursive: true})
+	//logger.Debugf("GetNodes start: key:%v  getResp:%v err:%v", key, getResp, err)
 
 	if err != nil {
 		return nil, err
 	}
 
 	var list []Node
+	//defer func() {
+	//	logger.Debugf("GetNodes end: list:%v", list)
+	//}()
 	s1 := fmt.Sprintf("\\/%s\\/nodes\\/(.*)", s.name)
 	regex := regexp.MustCompile(s1)
 
@@ -110,17 +176,17 @@ func (s *ServiceRegistry) GetNodes() ([]Node, error) {
 
 func (s *ServiceRegistry) Watch(watcher Watcher) {
 	key := fmt.Sprintf("/%s/nodes", s.name)
-	logger.Debugf("watch " + key)
+	logger.Infof("Watch start...:" + key)
 	w := s.etcd_client.Watcher(key, &etcd.WatcherOptions{AfterIndex: 0, Recursive: true})
 
 	var retryInterval time.Duration = 1
 
 	for {
 		_, err := w.Next(s.ctx)
+		logger.Debugf("Watch next...:%v",err)
 		if err != nil {
-			logger.Debugf("Failed to connect to etcd. Will retry after %d sec \n", retryInterval)
+			logger.Warnf("Failed to connect to etcd. Will retry after %d sec \n", retryInterval)
 			time.Sleep(retryInterval * time.Second)
-
 			retryInterval = (retryInterval * 2) % 4096
 		} else {
 			if retryInterval > 1 {
@@ -136,3 +202,18 @@ func (s *ServiceRegistry) Watch(watcher Watcher) {
 		}
 	}
 }
+
+func healthCheck(urlHealth string)  (error){
+	u, err := url.Parse(urlHealth)
+	if err != nil {
+		err = fmt.Errorf("err:%v, url:%v", err, urlHealth)
+		return err
+	}
+	u.Path = "/health"
+	resp, err := http.Get(u.String())
+	if err != nil {
+		err = fmt.Errorf("err:%v, url:%v, resp:%v", err, urlHealth, resp)
+		return err
+	}
+	return nil
+}
diff --git a/controllers/health.go b/controllers/health.go
index b984c32..ce805df 100644
--- a/controllers/health.go
+++ b/controllers/health.go
@@ -1,16 +1,22 @@
 package controllers
 
 import (
-	"github.com/astaxie/beego"
-	"imgfit/logger"
+	//"imgfit/logger"
+	"net/http"
 )
 
-type GroupCacheHealthController struct {
-	beego.Controller
-}
+//type GroupCacheHealthController struct {
+//	beego.Controller
+//}
+//
+//func (o *GroupCacheHealthController) Get() {
+//	logger.Debugf("GroupCacheHealthController ")
+//	o.Ctx.ResponseWriter.WriteHeader(200)
+//	return
+//}
 
-func (o *GroupCacheHealthController) Get() {
-	logger.Debugf("GroupCacheHealthController ")
-	o.Ctx.ResponseWriter.WriteHeader(200)
-	return
+func HealthHandler(w http.ResponseWriter, r *http.Request)  {
+	//logger.Debugf("url:%v", r)
+	//logger.Debugf("hello health")
+	w.WriteHeader(200)
 }
\ No newline at end of file
diff --git a/controllers/root.go b/controllers/root.go
index e7e2212..84a7e47 100644
--- a/controllers/root.go
+++ b/controllers/root.go
@@ -5,13 +5,14 @@ import (
 	"github.com/astaxie/beego"
 	"imgfit/logger"
 	"os"
+	"net/http"
 	"strconv"
 )
 
-
-type GroupCacheController struct {
-	beego.Controller
-}
+//
+//type GroupCacheController struct {
+//	beego.Controller
+//}
 
 var (
 	cm *CacheManager
@@ -44,8 +45,10 @@ func InitFromEnvs() {
 	if err == nil {
 		cm.Join(sr)
 	} else {
-		logger.Infof("There is no service registry (etcd) found. Starts with single node")
+		logger.Warn("There is no service registry (etcd) found. Starts with single node")
 	}
+
+
 }
 
 func init()  {
@@ -61,23 +64,27 @@ func init()  {
 	logger.Debugf("cacheManager new ok: %v", cm)
 }
 
-func (o *GroupCacheController) Get() {
+func FileHandler(w http.ResponseWriter, r *http.Request)  {
 	//DOING 查groupcache, 命中返回， 无则继续执行
-	logger.Debugf("URI:%v", o.Ctx.Input.URI())
-	//key := fmt.Sprintf("%s_%s_%d_%d_%d", bucketName, imgPathUri, x, y, q)
-	//key := o.Ctx.Input.URI()[3:]
-	key := o.Ctx.Input.URI()
+	logger.Debugf("URI:%v", r.RequestURI)
+	key := r.RequestURI
 	logger.Debugf("key:%v cm:%v", key, cm)
 	result, err := cm.Get(key)
 	logger.Debugf("err:%v", err)
 	if err != nil {
 		//err
 		logger.Debugf("Get err:%v", err)
-		o.Abort(err.Error())
+		v, err := strconv.Atoi(err.Error())
+		if err != nil {
+			w.WriteHeader(500)
+			return
+		}
+		w.WriteHeader(v)
 		return
 	}
 	logger.Debugf("Get no err")
-	o.Ctx.ResponseWriter.Write(result)
+	w.WriteHeader(200)
+	w.Write(result)
 	return
 }
 
diff --git a/glide.lock b/glide.lock
index dad119a..075d005 100644
--- a/glide.lock
+++ b/glide.lock
@@ -1,5 +1,5 @@
 hash: e7753d0489df13637701e6545db21ccdf14140964905bd0cc650f2f0dbf24913
-updated: 2017-03-24T15:08:20.212899696+08:00
+updated: 2017-03-29T15:54:24.325538458+08:00
 imports:
 - name: github.com/astaxie/beego
   version: 323a1c4214101331a4b71922c23d19b7409ac71f
@@ -13,6 +13,17 @@ imports:
   - utils
 - name: github.com/chai2010/webp
   version: 3bf12259b1cd565687ea00c9e5a6b648868133c5
+- name: github.com/coreos/etcd
+  version: 36735d52a4fde4d3d7e568d15c212d83970a7aab
+  subpackages:
+  - client
+  - pkg/pathutil
+  - pkg/types
+  - version
+- name: github.com/coreos/go-semver
+  version: 568e959cd89871e61434c1143528d9162da89ef2
+  subpackages:
+  - semver
 - name: github.com/disintegration/imaging
   version: ac27d1805a555e1754fa177216ee07f4e63c30b5
 - name: github.com/goamz/goamz
@@ -22,6 +33,18 @@ imports:
   - s3
 - name: github.com/golang/glog
   version: 23def4e6c14b4da8ac2ed8007337bc5eb5007998
+- name: github.com/golang/groupcache
+  version: 02826c3e79038b59d737d3b1c0a1d937f71a4433
+  subpackages:
+  - consistenthash
+  - groupcachepb
+  - lru
+  - singleflight
+- name: github.com/golang/protobuf
+  version: 4bd1920723d7b7c925de087aa32e2187708897f7
+  subpackages:
+  - jsonpb
+  - proto
 - name: github.com/issue9/assert
   version: 598d99b69097887ab251b29e40a1341e8f9657eb
 - name: github.com/smartystreets/goconvey
@@ -30,6 +53,10 @@ imports:
   - convey
   - convey/gotest
   - convey/reporting
+- name: github.com/ugorji/go
+  version: ded73eae5db7e7a0ef6f55aace87a2873c5d2b74
+  subpackages:
+  - codec
 - name: github.com/vaughan0/go-ini
   version: a98ad7ee00ec53921f08832bc06ecf7fd600e6a1
 - name: golang.org/x/image
@@ -38,9 +65,17 @@ imports:
   - bmp
   - tiff
   - tiff/lzw
+- name: golang.org/x/net
+  version: f2499483f923065a842d38eb4c7f1927e6fc6e6d
+  subpackages:
+  - context
+  - http2
+  - http2/hpack
+  - internal/timeseries
+  - trace
 testImports:
 - name: github.com/gopherjs/gopherjs
-  version: 0cc212b4ef1943b61e894a7d56490575b3216439
+  version: 3496c6f94e1b945f3fc9580f6982675c0a74cd6c
   subpackages:
   - js
 - name: github.com/jtolds/gls
diff --git a/main.go b/main.go
index c9826e3..8a283f5 100644
--- a/main.go
+++ b/main.go
@@ -9,11 +9,14 @@ import (
 	_ "imgfit/routers"
 	_ "imgfit/logger"
 	"github.com/astaxie/beego"
+	"imgfit/logger"
+	"net/http"
 	"imgfit/controllers"
 	"strconv"
 )
 
 
+
 func main() {
 
 	//beego.RunMode = "prod"
@@ -28,7 +31,12 @@ func main() {
 		beego.Run()
 	}else {
 		//cache ser
-		beego.Run(":"+strconv.Itoa(httpCachePort))
+		http.HandleFunc("/health", controllers.HealthHandler)
+		http.HandleFunc("/", controllers.FileHandler)
+		if err = http.ListenAndServe(":"+strconv.Itoa(httpCachePort), nil); err != nil {
+			logger.Errorf("err:%v", err)
+		}
+		//beego.Run(":"+strconv.Itoa(httpCachePort))
 	}
 
 	return
diff --git a/routers/router.go b/routers/router.go
index 418a88d..1312eab 100644
--- a/routers/router.go
+++ b/routers/router.go
@@ -14,25 +14,6 @@ import (
 )
 
 func init() {
-	//ns := beego.NewNamespace("/v1",
-	//	//beego.NSNamespace("/object",
-	//	//	beego.NSInclude(
-	//	//		&controllers.ObjectController{},
-	//	//	),
-	//	//),
-	//	//beego.NSNamespace("/",
-	//		beego.NSInclude(
-	//			&controllers.ImgfitController{},
-	//		),
-	//	//),
-	//)
-	//beego.AddNamespace(ns)
-	//beego.Router("/v1/",&controllers.ImgfitController{},"get:ApiV1Func")
-	//beego.Router("/v2/",&controllers.ImgfitController{},"get:ApiV2Func")
-	//beego.AutoRouter(&controllers.ObjectController{})
-	//beego.Get("/",func(ctx *context.Context){
-	//	ctx.Output.Body([]byte("hello world"))
-	//})
 	able, err := beego.AppConfig.Bool("EnableMyCacheSer")
 	if err != nil {
 		logger.Infof("No EnableMyCacheSer err:%v", err)
@@ -41,8 +22,6 @@ func init() {
 
 	if able{
 		logger.Infof("EnableMyCacheSer ok")
-		beego.Router("/*", &controllers.GroupCacheController{})
-		beego.Router("/health", &controllers.GroupCacheHealthController{})
 	}else {
 		beego.Router("/v1/*", &controllers.ImgfitV1Controller{})
 		beego.Router("/v2/*", &controllers.ImgfitV2Controller{})
diff --git a/vendor/github.com/golang/groupcache/consistenthash/consistenthash.go b/vendor/github.com/golang/groupcache/consistenthash/consistenthash.go
index a9c56f0..e6b9fde 100644
--- a/vendor/github.com/golang/groupcache/consistenthash/consistenthash.go
+++ b/vendor/github.com/golang/groupcache/consistenthash/consistenthash.go
@@ -19,6 +19,7 @@ package consistenthash
 
 import (
 	"hash/crc32"
+	"fmt"
 	"sort"
 	"strconv"
 )
@@ -33,6 +34,10 @@ type Map struct {
 }
 
 func New(replicas int, fn Hash) *Map {
+	fmt.Printf("New replicas:%v fh:%v start\n", replicas, fn)
+	defer func() {
+		fmt.Printf("New replicas:%v fh:%v end\n", replicas, fn)
+	} ()
 	m := &Map{
 		replicas: replicas,
 		hash:     fn,
@@ -51,6 +56,10 @@ func (m *Map) IsEmpty() bool {
 
 // Adds some keys to the hash.
 func (m *Map) Add(keys ...string) {
+	fmt.Printf("Map Add keys:%v m.keys:%v start\n", keys, m.keys)
+	defer func() {
+		fmt.Printf("Map Add m.keys:%v end\n",m.keys)
+	} ()
 	for _, key := range keys {
 		for i := 0; i < m.replicas; i++ {
 			hash := int(m.hash([]byte(strconv.Itoa(i) + key)))
@@ -63,6 +72,10 @@ func (m *Map) Add(keys ...string) {
 
 // Gets the closest item in the hash to the provided key.
 func (m *Map) Get(key string) string {
+	fmt.Printf("Map Get key:%v m.keys:%v start\n", key, m.keys)
+	defer func() {
+		fmt.Printf("Map Get m.keys:%v end\n",m.keys)
+	} ()
 	if m.IsEmpty() {
 		return ""
 	}
@@ -76,6 +89,7 @@ func (m *Map) Get(key string) string {
 	if idx == len(m.keys) {
 		idx = 0
 	}
+	fmt.Printf("idx:%v...hash:%v\n....v:%v.......vv:%v\n", idx, hash, m.keys[idx], m.hashMap[m.keys[idx]])
 
 	return m.hashMap[m.keys[idx]]
 }
diff --git a/vendor/github.com/golang/groupcache/groupcache.go b/vendor/github.com/golang/groupcache/groupcache.go
index 9499dbb..15e1ded 100644
--- a/vendor/github.com/golang/groupcache/groupcache.go
+++ b/vendor/github.com/golang/groupcache/groupcache.go
@@ -34,6 +34,7 @@ import (
 	pb "github.com/golang/groupcache/groupcachepb"
 	"github.com/golang/groupcache/lru"
 	"github.com/golang/groupcache/singleflight"
+	"fmt"
 )
 
 // A Getter loads data for a key.
@@ -197,18 +198,27 @@ func (g *Group) Name() string {
 }
 
 func (g *Group) initPeers() {
+	fmt.Printf("Group.initPeers Begin g.peers:%v\n", g.peers)
+	defer func() {
+		fmt.Printf("Group.initPeers End g.peers:%v\n", g.peers)
+	}()
 	if g.peers == nil {
 		g.peers = getPeers()
 	}
 }
 
 func (g *Group) Get(ctx Context, key string, dest Sink) error {
+	fmt.Printf("Group.Get key:%v..Begin\n", key)
+	defer func(key string) {
+		fmt.Printf("Group.Get key:%v..End\n", key)
+	}(key)
 	g.peersOnce.Do(g.initPeers)
 	g.Stats.Gets.Add(1)
 	if dest == nil {
 		return errors.New("groupcache: nil dest Sink")
 	}
 	value, cacheHit := g.lookupCache(key)
+	fmt.Printf("Group.Get g.lookupCache cacheHit:%v\n", cacheHit)
 
 	if cacheHit {
 		g.Stats.CacheHits.Add(1)
@@ -221,6 +231,7 @@ func (g *Group) Get(ctx Context, key string, dest Sink) error {
 	// case will likely be one caller.
 	destPopulated := false
 	value, destPopulated, err := g.load(ctx, key, dest)
+	fmt.Printf("Group Get g.load destPopulated:%v\n", destPopulated)
 	if err != nil {
 		return err
 	}
@@ -232,6 +243,11 @@ func (g *Group) Get(ctx Context, key string, dest Sink) error {
 
 // load loads key either by invoking the getter locally or by sending it to another machine.
 func (g *Group) load(ctx Context, key string, dest Sink) (value ByteView, destPopulated bool, err error) {
+	fmt.Printf("Group load key:%v..Begin\n", key)
+	defer func(key string) {
+		fmt.Printf("Group load key:%v..End\n", key)
+	}(key)
+
 	g.Stats.Loads.Add(1)
 	viewi, err := g.loadGroup.Do(key, func() (interface{}, error) {
 		// Check the cache again because singleflight can only dedup calls
@@ -262,8 +278,17 @@ func (g *Group) load(ctx Context, key string, dest Sink) (value ByteView, destPo
 		g.Stats.LoadsDeduped.Add(1)
 		var value ByteView
 		var err error
+
+		fmt.Printf("g.loadGroup.Do  key:%v..Begin\n", key)
+		defer func(key string) {
+			fmt.Printf("g.loadGroup.Do key:%v..End\n", key)
+		}(key)
+		fmt.Printf("REAL WORK traverse pickPeer\n")
+
 		if peer, ok := g.peers.PickPeer(key); ok {
+			fmt.Printf("REAL WORK2 peer:%v  key:%v\n", peer, key)
 			value, err = g.getFromPeer(ctx, peer, key)
+			fmt.Printf("REAL WORK2 peer:%v err:%v key:%v\n", peer, err, key)
 			if err == nil {
 				g.Stats.PeerLoads.Add(1)
 				return value, nil
@@ -274,7 +299,10 @@ func (g *Group) load(ctx Context, key string, dest Sink) (value ByteView, destPo
 			// probably boring (normal task movement), so not
 			// worth logging I imagine.
 		}
+
+		fmt.Printf("REAL WORK3. peer get key fail\n")
 		value, err = g.getLocally(ctx, key, dest)
+		fmt.Printf("REAL WORK4. g.getLocally err:%v\n", err)
 		if err != nil {
 			g.Stats.LocalLoadErrs.Add(1)
 			return nil, err
@@ -291,6 +319,10 @@ func (g *Group) load(ctx Context, key string, dest Sink) (value ByteView, destPo
 }
 
 func (g *Group) getLocally(ctx Context, key string, dest Sink) (ByteView, error) {
+	fmt.Printf("Group.getLocally  key:%v..g:%v ctx:%v dst:%vBegin\n", key, g, ctx, dest)
+	defer func(key string) {
+		fmt.Printf("Group.getLocally  key:%v. End\n", key)
+	}(key)
 	err := g.getter.Get(ctx, key, dest)
 	if err != nil {
 		return ByteView{}, err
@@ -299,12 +331,19 @@ func (g *Group) getLocally(ctx Context, key string, dest Sink) (ByteView, error)
 }
 
 func (g *Group) getFromPeer(ctx Context, peer ProtoGetter, key string) (ByteView, error) {
+	fmt.Printf("Group.getFromPeer  key:%v..peer:%v Group:%v Begin\n", key, peer, g)
+	defer func(key string) {
+		fmt.Printf("Group.getFromPeer  key:%v..peer:%v End\n", key, peer)
+	}(key)
+
 	req := &pb.GetRequest{
 		Group: &g.name,
 		Key:   &key,
 	}
 	res := &pb.GetResponse{}
+	fmt.Printf("Group.getFromPeer peer.Get start res:%v req:%v peer:%v\n", res, req, peer)
 	err := peer.Get(ctx, req, res)
+	fmt.Printf("Group.getFromPeer peer.Get end err:%v   \n", err)
 	if err != nil {
 		return ByteView{}, err
 	}
@@ -319,18 +358,30 @@ func (g *Group) getFromPeer(ctx Context, peer ProtoGetter, key string) (ByteView
 }
 
 func (g *Group) lookupCache(key string) (value ByteView, ok bool) {
+	fmt.Printf("Group.lookupCache  key:%v Begin\n", key)
+	defer func(key string) {
+		fmt.Printf("Group.lookupCache  key:%v End\n", key)
+	}(key)
+
 	if g.cacheBytes <= 0 {
 		return
 	}
 	value, ok = g.mainCache.get(key)
+ 	fmt.Printf("Group.lookupCache  g.mainCache.get ok:%v \n", ok)
 	if ok {
 		return
 	}
 	value, ok = g.hotCache.get(key)
+	fmt.Printf("Group.lookupCache  g.hotCache.get ok:%v \n", ok)
 	return
 }
 
 func (g *Group) populateCache(key string, value ByteView, cache *cache) {
+	fmt.Printf("Group.populateCache  key:%v..Begin\n", key)
+	defer func(key string) {
+		fmt.Printf("Group.populateCache  key:%v..End\n", key)
+	}(key)
+
 	if g.cacheBytes <= 0 {
 		return
 	}
diff --git a/vendor/github.com/golang/groupcache/http.go b/vendor/github.com/golang/groupcache/http.go
index 14eb345..41e46ba 100644
--- a/vendor/github.com/golang/groupcache/http.go
+++ b/vendor/github.com/golang/groupcache/http.go
@@ -32,7 +32,8 @@ import (
 
 const defaultBasePath = "/_groupcache/"
 
-const defaultReplicas = 50
+//const defaultReplicas = 50
+const defaultReplicas = 3
 
 // HTTPPool implements PeerPicker for a pool of HTTP peers.
 type HTTPPool struct {
@@ -88,6 +89,10 @@ var httpPoolMade bool
 // Unlike NewHTTPPool, this function does not register the created pool as an HTTP handler.
 // The returned *HTTPPool implements http.Handler and must be registered using http.Handle.
 func NewHTTPPoolOpts(self string, o *HTTPPoolOptions) *HTTPPool {
+	fmt.Printf("HTTPPool.PickPeer self:%v begin\n", self)
+	defer func() {
+		fmt.Printf("HTTPPool.PickPeer self:%v end\n", self)
+	}()
 	if httpPoolMade {
 		panic("groupcache: NewHTTPPool must be called only once")
 	}
@@ -118,6 +123,10 @@ func NewHTTPPoolOpts(self string, o *HTTPPoolOptions) *HTTPPool {
 func (p *HTTPPool) Set(peers ...string) {
 	p.mu.Lock()
 	defer p.mu.Unlock()
+	fmt.Printf("HTTPPool.PickPeer peers:%v begin\n", peers)
+	defer func() {
+		fmt.Printf("HTTPPool.PickPeer p.httpGetters:%v end\n", p.httpGetters)
+	}()
 	p.peers = consistenthash.New(p.opts.Replicas, p.opts.HashFn)
 	p.peers.Add(peers...)
 	p.httpGetters = make(map[string]*httpGetter, len(peers))
@@ -129,17 +138,29 @@ func (p *HTTPPool) Set(peers ...string) {
 func (p *HTTPPool) PickPeer(key string) (ProtoGetter, bool) {
 	p.mu.Lock()
 	defer p.mu.Unlock()
+	fmt.Printf("HTTPPool.PickPeer key:%v begin\n", key)
+	defer func() {
+		fmt.Printf("HTTPPool.PickPeer key:%v end\n", key)
+	}()
 	if p.peers.IsEmpty() {
+		fmt.Printf("HTTPPool.PickPeer key:%v p.peers.IsEmpty\n", key)
 		return nil, false
 	}
 	if peer := p.peers.Get(key); peer != p.self {
+		fmt.Printf("HTTPPool.PickPeer key:%v peer != p.self, peer:%v != p.self:%v\n", key, peer, p.self)
 		return p.httpGetters[peer], true
 	}
+
+	fmt.Printf("HTTPPool.PickPeer key:%v peer == p.self, p.self:%v\n", key, p.self)
 	return nil, false
 }
 
 func (p *HTTPPool) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 	// Parse request.
+	fmt.Printf("HTTPPool.ServeHTTP start\n")
+	defer func() {
+		fmt.Printf("HTTPPool.ServeHTTP end\n")
+	}()
 	if !strings.HasPrefix(r.URL.Path, p.opts.BasePath) {
 		panic("HTTPPool serving unexpected path: " + r.URL.Path)
 	}
@@ -153,6 +174,7 @@ func (p *HTTPPool) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 
 	// Fetch the value for this group/key.
 	group := GetGroup(groupName)
+	fmt.Printf("HTTPPool.ServeHTTP group:%v key:%v\n", group, key)
 	if group == nil {
 		http.Error(w, "no such group: "+groupName, http.StatusNotFound)
 		return
@@ -165,6 +187,7 @@ func (p *HTTPPool) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 	group.Stats.ServerRequests.Add(1)
 	var value []byte
 	err := group.Get(ctx, key, AllocatingByteSliceSink(&value))
+	fmt.Printf("HTTPPool.ServeHTTP group.Get key end err:%v\n", err)
 	if err != nil {
 		http.Error(w, err.Error(), http.StatusInternalServerError)
 		return
diff --git a/vendor/github.com/golang/groupcache/lru/lru.go b/vendor/github.com/golang/groupcache/lru/lru.go
index cdfe299..cde9f09 100644
--- a/vendor/github.com/golang/groupcache/lru/lru.go
+++ b/vendor/github.com/golang/groupcache/lru/lru.go
@@ -18,6 +18,7 @@ limitations under the License.
 package lru
 
 import "container/list"
+import "fmt"
 
 // Cache is an LRU cache. It is not safe for concurrent access.
 type Cache struct {
@@ -65,6 +66,7 @@ func (c *Cache) Add(key Key, value interface{}) {
 	}
 	ele := c.ll.PushFront(&entry{key, value})
 	c.cache[key] = ele
+	fmt.Printf("LRU c.cache: %v\n", c.cache)
 	if c.MaxEntries != 0 && c.ll.Len() > c.MaxEntries {
 		c.RemoveOldest()
 	}
diff --git a/vendor/github.com/golang/groupcache/peers.go b/vendor/github.com/golang/groupcache/peers.go
index a74a79b..cd8de0d 100644
--- a/vendor/github.com/golang/groupcache/peers.go
+++ b/vendor/github.com/golang/groupcache/peers.go
@@ -20,6 +20,7 @@ package groupcache
 
 import (
 	pb "github.com/golang/groupcache/groupcachepb"
+	"fmt"
 )
 
 // Context is an opaque value passed through calls to the
@@ -53,13 +54,16 @@ var (
 // RegisterPeerPicker registers the peer initialization function.
 // It is called once, when the first group is created.
 func RegisterPeerPicker(fn func() PeerPicker) {
+	fmt.Printf("RegisterPeerPicker: start\n")
 	if portPicker != nil {
 		panic("RegisterPeerPicker called more than once")
 	}
 	portPicker = fn
+	fmt.Printf("RegisterPeerPicker: end fn:%v\n", fn)
 }
 
 func getPeers() PeerPicker {
+	fmt.Printf("getPeers: start\n")
 	if portPicker == nil {
 		return NoPeers{}
 	}
@@ -67,5 +71,6 @@ func getPeers() PeerPicker {
 	if pk == nil {
 		pk = NoPeers{}
 	}
+	fmt.Printf("getPeers: end pk:%v\n", pk)
 	return pk
 }
